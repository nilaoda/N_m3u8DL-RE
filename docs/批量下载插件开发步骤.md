# 批量下载插件开发步骤文档

## 项目概述

本插件旨在为N_m3u8DL-RE添加批量下载功能，支持从文本文件读取多个M3U8 URL并进行批量下载。

## 功能需求

### 核心功能
1. **批量URL读取**: 从文本文件读取M3U8 URL列表
2. **顺序/并行下载**: 支持按顺序或并行下载多个流
3. **进度管理**: 显示批量下载的整体进度
4. **错误处理**: 单个URL下载失败不影响其他下载

### 配置参数
- 批量文件路径
- 并发下载数量
- 输出目录结构
- 失败重试机制

## 技术架构

### 插件架构设计
```
BatchDownloadPlugin
├── 实现IPlugin接口
├── 配置文件集成
├── URL列表解析器
├── 批量下载管理器
└── 进度监控器
```

### 文件结构
```
extend/
├── BatchDownloadPlugin.cs      # 批量下载插件主类
├── BatchDownloadConfig.cs      # 批量下载配置类
├── PluginConfig.json           # 更新配置文件
└── PluginManager.cs            # 更新插件管理器
```

## 详细实现步骤

### 步骤1: 创建批量下载配置类
**文件**: `/workspace/N_m3u8DL-RE-src/src/N_m3u8DL-RE/extend/BatchDownloadConfig.cs`

```csharp
public class BatchDownloadConfig
{
    public bool Enabled { get; set; } = false;
    public string BatchFile { get; set; } = "urls.txt";
    public int MaxConcurrentDownloads { get; set; } = 1;
    public string OutputDirectory { get; set; } = "batch_output";
    public int RetryCount { get; set; } = 3;
    public bool CreateSubdirectories { get; set; } = true;
}
```

### 步骤2: 更新插件配置类
**文件**: `/workspace/N_m3u8DL-RE-src/src/N_m3u8DL-RE/extend/PluginConfig.json`

在现有配置基础上添加：
```json
{
  "BatchDownload": {
    "Enabled": true,
    "BatchFile": "urls.txt",
    "MaxConcurrentDownloads": 1,
    "OutputDirectory": "batch_output",
    "RetryCount": 3,
    "CreateSubdirectories": true
  }
}
```

### 步骤3: 创建批量下载插件主类
**文件**: `/workspace/N_m3u8DL-RE-src/src/N_m3u8DL-RE/extend/BatchDownloadPlugin.cs`

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using N_m3u8DL_RE.Common.Log;

namespace N_m3u8DL_RE.Plugin
{
    public class BatchDownloadPlugin : IPlugin
    {
        private BatchDownloadConfig? _config;
        private List<string> _urlList = new List<string>();
        private int _currentIndex = 0;
        
        public void Initialize(PluginConfig? config)
        {
            _config = config?.BatchDownload;
            
            if (_config?.Enabled == true)
            {
                LoadUrlList();
                Logger.Info($"[BatchDownloadPlugin] Loaded {_urlList.Count} URLs from {_config.BatchFile}");
            }
        }
        
        public void OnFileDownloaded(string filePath, int downloadCount)
        {
            // 批量下载插件的主要逻辑在程序启动时处理
            // 此方法用于处理单个下载完成后的回调（可选）
        }
        
        private void LoadUrlList()
        {
            if (File.Exists(_config?.BatchFile))
            {
                var lines = File.ReadAllLines(_config.BatchFile);
                foreach (var line in lines)
                {
                    var trimmedLine = line.Trim();
                    if (!string.IsNullOrEmpty(trimmedLine) && !trimmedLine.StartsWith("#"))
                    {
                        _urlList.Add(trimmedLine);
                    }
                }
            }
        }
        
        public List<string> GetUrlList() => _urlList;
        public bool HasUrls() => _urlList.Count > 0;
    }
}
```

### 步骤4: 更新插件管理器
**文件**: `/workspace/N_m3u8DL-RE-src/src/N_m3u8DL-RE/extend/PluginManager.cs`

在`PluginConfig`类中添加：
```csharp
public class PluginConfig
{
    public UASwitcherConfig? UASwitcher { get; set; }
    public ProxySwitcherConfig? ProxySwitcher { get; set; }
    public BatchDownloadConfig? BatchDownload { get; set; }  // 新增
}
```

在`IsPluginEnabled`方法中添加：
```csharp
private static bool IsPluginEnabled(string pluginName)
{
    return pluginName switch
    {
        "UASwitcher" => _config?.UASwitcher?.Enabled ?? false,
        "ProxySwitcher" => _config?.ProxySwitcher?.Enabled ?? false,
        "BatchDownload" => _config?.BatchDownload?.Enabled ?? false,  // 新增
        _ => false
    };
}
```

### 步骤5: 修改主程序输入处理逻辑
**文件**: `/workspace/N_m3u8DL-RE-src/src/N_m3u8DL-RE/Program.cs`

在`Main`方法中添加批量下载处理逻辑：

```csharp
// 在插件系统初始化后，检查是否启用批量下载
bool batchDownloadEnabled = false;
BatchDownloadPlugin? batchPlugin = null;

try 
{
    var pluginManagerType = Type.GetType("N_m3u8DL_RE.Plugin.PluginManager, N_m3u8DL-RE");
    if (pluginManagerType != null)
    {
        var getConfigMethod = pluginManagerType.GetMethod("GetConfig");
        if (getConfigMethod != null)
        {
            var config = getConfigMethod.Invoke(null, null) as PluginConfig;
            batchDownloadEnabled = config?.BatchDownload?.Enabled ?? false;
            
            if (batchDownloadEnabled)
            {
                // 获取批量下载插件实例
                var getPluginsMethod = pluginManagerType.GetMethod("GetPlugins", 
                    BindingFlags.NonPublic | BindingFlags.Static);
                if (getPluginsMethod != null)
                {
                    var plugins = getPluginsMethod.Invoke(null, null) as List<IPlugin>;
                    batchPlugin = plugins?.OfType<BatchDownloadPlugin>().FirstOrDefault();
                }
            }
        }
    }
}
catch (Exception ex)
{
    Console.WriteLine($"[BatchDownload] Failed to check batch download status: {ex.Message}");
}

// 如果启用批量下载且有URL列表，则执行批量下载
if (batchDownloadEnabled && batchPlugin?.HasUrls() == true)
{
    await ExecuteBatchDownload(batchPlugin, option);
    return;
}

// 否则执行正常的单URL下载流程
// ... 原有的单URL下载逻辑
```

### 步骤6: 实现批量下载执行方法
**文件**: `/workspace/N_m3u8DL-RE-src/src/N_m3u8DL-RE/Program.cs`

添加批量下载执行方法：

```csharp
private static async Task ExecuteBatchDownload(BatchDownloadPlugin batchPlugin, MyOptions option)
{
    var urls = batchPlugin.GetUrlList();
    Logger.InfoMarkUp($"[BatchDownload] Starting batch download with {urls.Count} URLs");
    
    int successCount = 0;
    int failCount = 0;
    
    for (int i = 0; i < urls.Count; i++)
    {
        var url = urls[i];
        Logger.InfoMarkUp($"[BatchDownload] Processing URL {i + 1}/{urls.Count}: {url}");
        
        try
        {
            // 创建子目录（如果配置允许）
            var originalSaveDir = option.SaveDir;
            if (batchPlugin.GetConfig()?.CreateSubdirectories == true)
            {
                var subDir = Path.Combine(originalSaveDir ?? ".", $"batch_item_{i + 1}");
                Directory.CreateDirectory(subDir);
                option.SaveDir = subDir;
            }
            
            // 执行单个URL下载（重用现有的下载逻辑）
            await ExecuteSingleDownload(url, option);
            successCount++;
            
            // 恢复原始保存目录
            option.SaveDir = originalSaveDir;
        }
        catch (Exception ex)
        {
            Logger.ErrorMarkUp($"[BatchDownload] Failed to download URL {i + 1}: {ex.Message}");
            failCount++;
        }
    }
    
    Logger.InfoMarkUp($"[BatchDownload] Batch download completed. Success: {successCount}, Failed: {failCount}");
}

private static async Task ExecuteSingleDownload(string url, MyOptions option)
{
    // 重用Program.cs中现有的单URL下载逻辑
    // 需要将原有的下载逻辑提取为独立方法
    var parserConfig = CreateParserConfig(option);
    var extractor = new StreamExtractor(parserConfig);
    
    await RetryUtil.WebRequestRetryAsync(async () =>
    {
        await extractor.LoadSourceFromUrlAsync(url);
        return true;
    });
    
    // ... 继续执行后续的流提取和下载逻辑
}
```

### 步骤7: 明确URL输入文件and输出路径
**输入文件**: `/workspace/input.txt`
**输出路径** /workspace/mpegts.js/demo/output


```

## 测试计划

### 单元测试
创建的测试文件名前缀为deletable
1. **URL列表解析测试**: 验证各种格式的URL文件解析
2. **配置加载测试**: 验证配置文件正确加载
3. **插件初始化测试**: 验证插件正确初始化

### 集成测试
1. **单URL批量测试**: 使用单个URL验证批量下载流程
2. **多URL顺序测试**: 验证多个URL按顺序下载
3. **错误处理测试**: 验证单个URL失败不影响其他下载

### 功能测试
1. **输出目录结构**: 验证子目录创建功能
2. **进度显示**: 验证批量下载进度显示
3. **日志输出**: 验证详细的日志记录

## 部署和集成

### 编译要求
- 确保所有新增文件在N_m3u8DL-RE.csproj中被正确引用
- 验证插件配置文件被复制到输出目录

### 使用说明
2. 修改PluginConfig.json启用批量下载插件
3. 运行程序，自动检测并执行批量下载

## 风险控制

### 兼容性风险
- 保持与现有插件系统的兼容性
- 不影响单URL下载功能

### 性能风险
- 控制并发下载数量，避免资源耗尽
- 实现合理的错误重试机制

### 稳定性风险
- 完善的异常处理机制
- 单个URL失败不影响整体流程

## 后续优化方向(以后再考虑)

1. **并行下载**: 实现真正的并行下载支持
2. **断点续传**: 支持批量下载的断点续传
3. **智能调度**: 根据网络状况动态调整并发数量
4. **Web界面**: 提供Web界面管理批量下载任务