# N_m3u8DL-RE 函数调用关系分析

## 主程序执行流程分析

### 1. 程序入口函数调用链

#### Main 函数 (`Program.cs:28`)
```csharp
static async Task Main(string[] args)
{
    // 插件系统初始化
    PluginManager.LoadPlugins() [通过反射调用]
    
    // 全球化设置
    ResString.CurrentLoc = loc
    CultureInfo.DefaultThreadCurrentCulture = new CultureInfo(loc)
    
    // 命令行处理
    CommandInvoker.InvokeArgs(args, DoWorkAsync)
}
```

#### 命令行调用器 (`CommandInvoker.cs`)
```csharp
public static async Task InvokeArgs(string[] args, Func<MyOption, Task> doWorkAsync)
{
    // 解析命令行参数
    MyOption.Parse(args)
    
    // 执行主工作函数
    await doWorkAsync(option)
}
```

### 2. 核心工作函数调用链

#### DoWorkAsync 函数 (`Program.cs:114`)
```csharp
static async Task DoWorkAsync(MyOption option)
{
    // 配置验证阶段
    ValidateExternalTools(option)
    ValidateProxySettings(option)
    ValidateParameterConstraints(option)
    
    // 流媒体解析阶段
    var extractor = new StreamExtractor(parserConfig)
    await extractor.LoadSourceFromUrlAsync(url)
    var streams = await extractor.ExtractStreamsAsync()
    
    // 流选择阶段
    var selectedStreams = SelectStreams(option, streams)
    
    // 下载执行阶段
    await ExecuteDownload(option, extractor, selectedStreams)
}
```

## 关键模块函数调用关系

### 流提取器模块 (StreamExtractor)

#### LoadSourceFromUrlAsync 函数 (`StreamExtractor.cs:32`)
```csharp
public async Task LoadSourceFromUrlAsync(string url)
{
    // URL类型判断
    if (url.StartsWith("file:"))
        File.ReadAllTextAsync(uri.LocalPath)
    else if (url.StartsWith("http"))
        HTTPUtil.GetWebSourceAndNewUrlAsync(url, parserConfig.Headers)
    else if (File.Exists(url))
        File.ReadAllTextAsync(url)
    
    // 内容类型检测和提取器选择
    DetectContentType(rawText)
    CreateExtractor()
}
```

#### ExtractStreamsAsync 函数
```csharp
public async Task<List<StreamSpec>> ExtractStreamsAsync()
{
    // 调用具体提取器
    return await extractor.ExtractStreamsAsync()
    
    // 内部调用链:
    // HLSExtractor.ExtractStreamsAsync()
    //   → ParseMasterPlaylist()
    //   → ParseMediaPlaylist()
    //   → BuildStreamSpec()
    
    // DASHExtractor.ExtractStreamsAsync()
    //   → ParseMPD()
    //   → ExtractAdaptationSets()
    //   → BuildStreamSpec()
}
```

### 下载管理器模块 (DownloadManager)

#### SimpleDownloadManager.StartDownloadAsync()
```csharp
public async Task<bool> StartDownloadAsync()
{
    // 初始化阶段
    PrepareDownloadDirectory()
    CreateDownloadTasks()
    
    // 下载执行阶段
    await ExecuteParallelDownloads()
    
    // 后处理阶段
    await MergeDownloadedFiles()
    await ApplyDecryption()
    await PerformMuxing()
}
```

#### HTTPLiveRecordManager.StartRecordAsync()
```csharp
public async Task<bool> StartRecordAsync()
{
    // 直播流检测
    DetectLiveStream()
    
    // 录制循环
    while (IsStreamActive)
    {
        await FetchLiveSegments()
        await ProcessLiveSegments()
        await WaitForNextSegment()
    }
    
    // 录制后处理
    await FinalizeRecording()
}
```

## 工具类函数调用关系

### HTTPUtil 工具类

#### GetWebSourceAndNewUrlAsync 函数
```csharp
public static async Task<(string, string)> GetWebSourceAndNewUrlAsync(string url, Dictionary<string, string> headers)
{
    // HTTP请求执行
    using var client = CreateHttpClient(headers)
    using var response = await client.GetAsync(url)
    
    // 响应处理
    response.EnsureSuccessStatusCode()
    var content = await response.Content.ReadAsStringAsync()
    
    // URL重定向处理
    var finalUrl = GetFinalUrl(response)
    
    return (content, finalUrl)
}
```

### FilterUtil 工具类

#### SelectStreams 函数
```csharp
public static List<StreamSpec> SelectStreams(List<StreamSpec> streams)
{
    // 交互式选择界面
    DisplayStreamSelectionUI(streams)
    
    // 用户输入处理
    var selectedIndices = GetUserSelections()
    
    // 流过滤和排序
    return FilterAndSortStreams(streams, selectedIndices)
}
```

#### DoFilterKeep 函数
```csharp
public static List<StreamSpec> DoFilterKeep(List<StreamSpec> streams, string? filter)
{
    // 过滤器解析
    var filterConditions = ParseFilterExpression(filter)
    
    // 流匹配
    return streams.Where(stream => 
        MatchFilterConditions(stream, filterConditions)
    ).ToList()
}
```

## 加密解密模块函数调用

### AESUtil 工具类

#### DecryptAES128 函数
```csharp
public static byte[] DecryptAES128(byte[] encryptedData, byte[] key, byte[] iv)
{
    // AES解密初始化
    using var aes = Aes.Create()
    aes.Key = key
    aes.IV = iv
    aes.Mode = CipherMode.CBC
    aes.Padding = PaddingMode.PKCS7
    
    // 解密执行
    using var decryptor = aes.CreateDecryptor()
    return decryptor.TransformFinalBlock(encryptedData, 0, encryptedData.Length)
}
```

### MP4DecryptUtil 工具类

#### DecryptWithMP4Decrypt 函数
```csharp
public static async Task<bool> DecryptWithMP4Decrypt(string inputFile, string outputFile, string key)
{
    // 外部工具调用
    var processStartInfo = new ProcessStartInfo
    {
        FileName = "mp4decrypt",
        Arguments = $"--key {key} {inputFile} {outputFile}",
        UseShellExecute = false
    }
    
    // 进程执行和监控
    using var process = Process.Start(processStartInfo)
    await process.WaitForExitAsync()
    
    return process.ExitCode == 0
}
```

## 插件系统函数调用

### PluginManager 类

#### LoadPlugins 函数
```csharp
public static void LoadPlugins()
{
    // 插件目录扫描
    var pluginDirectory = GetPluginDirectory()
    var pluginFiles = Directory.GetFiles(pluginDirectory, "*.dll")
    
    // 插件加载和初始化
    foreach (var file in pluginFiles)
    {
        var assembly = Assembly.LoadFrom(file)
        var pluginTypes = assembly.GetTypes()
            .Where(t => typeof(IPlugin).IsAssignableFrom(t))
        
        foreach (var type in pluginTypes)
        {
            var plugin = Activator.CreateInstance(type) as IPlugin
            plugin?.Initialize()
        }
    }
}
```

## 关键函数调用时序图

### 点播下载时序
```
Main()
  → CommandInvoker.InvokeArgs()
    → DoWorkAsync()
      → StreamExtractor.LoadSourceFromUrlAsync()
        → HTTPUtil.GetWebSourceAndNewUrlAsync()
      → StreamExtractor.ExtractStreamsAsync()
        → HLSExtractor.ParseMasterPlaylist()
      → FilterUtil.SelectStreams()
      → SimpleDownloadManager.StartDownloadAsync()
        → DownloadUtil.DownloadSegments()
        → MergeUtil.MergeFiles()
        → MP4DecryptUtil.DecryptFiles()
```

### 直播录制时序
```
Main()
  → CommandInvoker.InvokeArgs()
    → DoWorkAsync()
      → StreamExtractor.LoadSourceFromUrlAsync()
      → StreamExtractor.ExtractStreamsAsync()
      → HTTPLiveRecordManager.StartRecordAsync()
        → DetectLiveStream() [循环]
        → FetchLiveSegments()
        → ProcessLiveSegments()
        → WaitForNextSegment()
      → FinalizeRecording()
```

## 函数调用深度分析

### 最深调用链示例
```
Program.Main()
  ↓ (1层)
CommandInvoker.InvokeArgs()
  ↓ (2层)  
Program.DoWorkAsync()
  ↓ (3层)
StreamExtractor.LoadSourceFromUrlAsync()
  ↓ (4层)
HTTPUtil.GetWebSourceAndNewUrlAsync()
  ↓ (5层)
HttpClient.GetAsync() [系统调用]
  ↓ (6层)
Socket通信层 [系统深度]
```

### 关键异步调用点
1. **HTTP请求** - `HTTPUtil.GetWebSourceAndNewUrlAsync()`
2. **文件IO** - `File.ReadAllTextAsync()`
3. **下载执行** - `SimpleDownloader.DownloadAsync()`
4. **外部工具调用** - `Process.WaitForExitAsync()`

## 性能关键函数

### 高频调用函数
1. **Logger.Info()** - 日志记录，频繁调用
2. **HTTPUtil 相关函数** - HTTP请求，网络IO密集
3. **Stream处理函数** - 数据流处理，内存操作密集

### 耗时操作函数
1. **网络请求** - HTTPUtil 相关函数
2. **文件操作** - 大文件读写和合并
3. **外部工具调用** - ffmpeg/mp4decrypt 进程启动

这个函数调用关系分析展示了项目的完整执行流程，从程序启动到下载完成的全过程，帮助理解各个模块之间的协作关系。